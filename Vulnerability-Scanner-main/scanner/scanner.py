import os
import json
import sqlite3
import subprocess
import threading
import time
import numpy as np
import pandas as pd
from datetime import datetime
from urllib.parse import urlparse
import re
import xml.etree.ElementTree as ET
import joblib
import random
from urllib.parse import urlparse
from datetime import datetime

# Define paths to our models
MODEL_PATHS = {
    "rf": "models/rf_model.pkl",
    "svm": "models/svm_model.pkl",
    "nn": "models/nn_model.pkl",
}

# CVSS Scoring
CVSS_SEVERITY = {
    "Critical": (9.0, 10.0),
    "High": (7.0, 8.9),
    "Medium": (4.0, 6.9),
    "Low": (0.1, 3.9),
    "None": (0.0, 0.0),
}


def init_db():
    """Initialize SQLite database for storing scan results"""
    conn = sqlite3.connect("db/scans.db")
    cursor = conn.cursor()

    # Create scans table
    cursor.execute(
        """
    CREATE TABLE IF NOT EXISTS scans (
        scan_id TEXT PRIMARY KEY,
        url TEXT NOT NULL,
        scan_date TEXT NOT NULL,
        status TEXT NOT NULL,
        tool_results TEXT,
        vulnerabilities TEXT,
        report_path TEXT
    )
    """
    )

    conn.commit()
    conn.close()


def get_all_scans():
    """Get all scans from database"""
    conn = sqlite3.connect("db/scans.db")
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    cursor.execute("SELECT * FROM scans ORDER BY scan_date DESC")
    scans = cursor.fetchall()

    conn.close()
    return scans


def get_scan_results(scan_id):
    """Get detailed scan results for a specific scan ID"""
    conn = sqlite3.connect("db/scans.db")
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    cursor.execute("SELECT * FROM scans WHERE scan_id = ?", (scan_id,))
    scan = cursor.fetchone()
    conn.close()
    print(json.dumps(dict(scan), indent=4))
    if scan and scan["vulnerabilities"]:
        scan_dict = dict(scan)
        scan_dict["vulnerabilities"] = json.loads(scan["vulnerabilities"])
        if scan["tool_results"]:
            scan_dict["tool_results"] = json.loads(scan["tool_results"])
        return scan_dict

    return None


def update_scan_status(scan_id, status, tool_results=None, vulnerabilities=None):
    """Update scan status in database"""
    conn = sqlite3.connect("db/scans.db")
    cursor = conn.cursor()

    if tool_results is not None and vulnerabilities is not None:
        tool_results_json = json.dumps(tool_results)
        vulnerabilities_json = json.dumps(vulnerabilities)
        cursor.execute(
            "UPDATE scans SET status = ?, tool_results = ?, vulnerabilities = ? WHERE scan_id = ?",
            (status, tool_results_json, vulnerabilities_json, scan_id),
        )
    else:
        cursor.execute(
            "UPDATE scans SET status = ? WHERE scan_id = ?", (status, scan_id)
        )

    conn.commit()
    conn.close()


def scan_url(scan_id, url, scan_date):
    """Initiate scanning for given URL with multiple tools"""
    # Create a new scan entry in database
    conn = sqlite3.connect("db/scans.db")
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO scans (scan_id, url, scan_date, status) VALUES (?, ?, ?, ?)",
        (scan_id, url, scan_date, "in_progress"),
    )
    conn.commit()
    conn.close()

    # Start scanning in a separate thread
    thread = threading.Thread(target=run_scans, args=(scan_id, url))
    thread.daemon = True
    thread.start()


def run_scans(scan_id, url):
    """Run all security scans on the target URL"""
    try:
        print(f"Starting scan for {url}")

        # Run various security tools
        results = {}
        vulnerabilities = []

        # # # Run SQLMap scan
        # results['sqlmap'] = run_sqlmap_scan(url)
        # # vulnerabilities.extend(parse_sqlmap_results(results['sqlmap']))

        # # Run Nikto scan
        # results['nikto'] = run_nikto_scan(url)
        # vulnerabilities.extend(parse_nikto_results(results['nikto']))

        # Run SQLMap scan
        results["sqlmap"] = simulate_sqlmap_scan(url)
        vulnerabilities.extend(parse_sqlmap_results(results["sqlmap"]))

        # Run Nikto scan
        results["nikto"] = simulate_nikto_scan(url)
        vulnerabilities.extend(parse_nikto_results(results["nikto"]))

        # Run OWASP ZAP scan if available
        try:
            results["zap"] = run_zap_scan(url)
            vulnerabilities.extend(parse_zap_results(results["zap"]))
        except Exception as e:
            print(f"Error running ZAP scan: {e}")
            results["zap"] = {
                "error": str(e),
                "details": "ZAP scanner not available or failed to run",
            }

        # Simulate Nessus results (since we can't directly integrate with Nessus)
        results["nessus"] = simulate_nessus_scan(url)
        vulnerabilities.extend(parse_nessus_results(results["nessus"]))

        time.sleep(6)  # Simulate some processing time

        # Categorize vulnerabilities and predict severity
        for vuln in vulnerabilities:
            if "cvss_score" not in vuln or not vuln["cvss_score"]:
                # Predict severity using ML models
                predicted_score = predict_cvss_score(vuln)
                vuln["cvss_score"] = predicted_score
                vuln["severity"] = get_severity_from_cvss(predicted_score)
            else:
                vuln["severity"] = get_severity_from_cvss(vuln["cvss_score"])

        # Group vulnerabilities by severity
        vuln_by_severity = {
            "Critical": [],
            "High": [],
            "Medium": [],
            "Low": [],
            "None": [],
        }

        for vuln in vulnerabilities:
            severity = vuln.get("severity", "None")
            vuln_by_severity[severity].append(vuln)

        # Update scan results in database
        update_scan_status(scan_id, "completed", results, vuln_by_severity)
        print(f"Scan completed for {url}")

    except Exception as e:
        print(f"Error during scan: {e}")
        update_scan_status(scan_id, "failed")


def run_sqlmap_scan(url):
    """Run SQLMap scan on target URL"""
    try:
        output_dir = f"./temp/sqlmap_{int(time.time())}"
        os.makedirs(output_dir, exist_ok=True)

        cmd = [
            "sqlmap",
            "-u",
            url,
            "--batch",
            "--output-dir=" + output_dir,
            "--forms",
            "--risk=1",
            "--level=1",
            "-o",
        ]

        # Run SQLMap process
        process = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        stdout, stderr = process.communicate()

        # Try to find results in the output directory
        results = {"command": " ".join(cmd), "stdout": stdout, "stderr": stderr}

        # Look for a target.txt or log file to extract results
        log_files = []
        for root, dirs, files in os.walk(output_dir):
            for file in files:
                if file.endswith(".txt") or file.endswith(".log"):
                    log_files.append(os.path.join(root, file))

        # If we found log files, read their contents
        if log_files:
            results["log_contents"] = {}
            for log_file in log_files:
                try:
                    with open(log_file, "r") as f:
                        results["log_contents"][os.path.basename(log_file)] = f.read()
                except:
                    pass

        # Check if there are any findings by parsing stdout or logs
        has_findings = False
        if "found" in stdout.lower() and "injection" in stdout.lower():
            has_findings = True
        elif "log_contents" in results:
            for content in results["log_contents"].values():
                if "found" in content.lower() and "injection" in content.lower():
                    has_findings = True
                    break

        if has_findings:
            results["findings"] = {
                "vulnerable": True,
                "details": "SQLMap found potential SQL injection vulnerabilities. Check logs for details.",
            }

        return results

    except Exception as e:
        return {"error": str(e), "details": "Failed to run SQLMap"}


def run_nikto_scan(url):
    """Run Nikto scan on target URL"""
    try:
        output_file = f"temp_nikto_{int(time.time())}.txt"
        cmd = [
            "nikto",
            "-h",
            url,
            "-o",
            output_file,
            "-Format",
            "txt",
            "-Tuning",
            "123",
        ]

        # Run Nikto process
        process = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        stdout, stderr = process.communicate()

        # Try to read output file
        try:
            with open(output_file, "r") as f:
                output = f.read()
            # Clean up temp file
            os.remove(output_file)
            return {"command": " ".join(cmd), "stdout": stdout, "output": output}
        except FileNotFoundError:
            return {
                "command": " ".join(cmd),
                "stdout": stdout,
                "stderr": stderr,
                "error": "Failed to read Nikto output file",
            }

    except Exception as e:
        return {"error": str(e), "details": "Failed to run Nikto"}


def run_zap_scan(url):
    """Run OWASP ZAP scan on target URL"""
    # Check if ZAP CLI is available
    zap_available = False
    try:
        process = subprocess.Popen(
            ["which", "zap-cli"], stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        stdout, _ = process.communicate()
        if stdout.strip():
            zap_available = True
    except:
        pass

    if not zap_available:
        # Fall back to a simulated ZAP scan since zap-cli isn't available
        return simulate_zap_scan(url)

    try:
        output_file = f"temp_zap_{int(time.time())}.xml"
        cmd = [
            "zap-cli",
            "quick-scan",
            "-s",
            "xss,sqli",
            "--self-contained",
            "-o",
            output_file,
            url,
        ]

        # Run ZAP CLI process
        process = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        stdout, stderr = process.communicate()

        # Try to read output file
        try:
            with open(output_file, "r") as f:
                output = f.read()
            # Clean up temp file
            os.remove(output_file)
            return {"command": " ".join(cmd), "stdout": stdout, "output": output}
        except FileNotFoundError:
            return {
                "command": " ".join(cmd),
                "stdout": stdout,
                "stderr": stderr,
                "error": "Failed to read ZAP output file",
            }

    except Exception as e:
        return {"error": str(e), "details": "Failed to run OWASP ZAP"}


def simulate_sqlmap_scan(url):
    """Simulate SQLMap scan results in normalized vulnerability format"""
    domain = urlparse(url).netloc

    # Define a pool of possible findings
    possible_findings = [
        {
            "type": "SQL Injection",
            "parameter": "id",
            "risk_options": ["Medium", "High"],
            "description": 'Potential SQL Injection vulnerability detected in the "id" parameter.',
        },
        {
            "type": "Boolean-based Blind SQL Injection",
            "parameter": "search",
            "risk_options": ["Medium"],
            "description": 'Boolean-based blind SQL injection may be possible in the "search" parameter.',
        },
        {
            "type": "Time-based Blind SQL Injection",
            "parameter": "category",
            "risk_options": ["Medium", "High"],
            "description": 'Time-based blind SQL injection vulnerability detected in the "category" parameter.',
        },
        {
            "type": "Error-based SQL Injection",
            "parameter": "user",
            "risk_options": ["High"],
            "description": 'Error-based SQL injection vulnerability found in the "user" parameter.',
        },
    ]

    # Randomly select 0 to 3 findings
    num_findings = random.randint(0, 3)
    selected_findings = (
        random.sample(possible_findings, num_findings) if num_findings > 0 else []
    )

    # Map SQLMap risk to normalized severity
    def map_risk_to_severity(risk):
        if risk == "High":
            return "High"
        elif risk == "Medium":
            return "Medium"
        else:
            return "Low"

    # Build normalized findings
    vulnerabilities = [
        {
            "tool": "SQLMap",
            "type": finding["type"],
            "parameter": finding["parameter"],
            "url": url,
            "severity": map_risk_to_severity(random.choice(finding["risk_options"])),
            "description": finding["description"],
            "details": finding,
            "cvss_score": 8.6 if "Injection" in finding["type"] else 6.0,
            "remediation": "Use parameterized queries, input validation, and ORM frameworks.",
        }
        for finding in selected_findings
    ]

    return {
        "simulated": True,
        "url": url,
        "scan_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "vulnerabilities": vulnerabilities,
        "details": "This is a simulated sqlmap scan as sqlmap was not found in the system.",
    }


def simulate_nikto_scan(url):
    """Simulate Nikto scan results in normalized vulnerability format"""
    domain = urlparse(url).netloc

    # Define a pool of possible Nikto findings
    possible_issues = [
        {
            "id": "HTTP-Methods",
            "name": "Unusual HTTP Methods Enabled",
            "description_template": "Potentially dangerous HTTP methods (e.g., TRACE, DELETE) enabled on {}",
            "severity_options": ["Low", "Medium"],
        },
        {
            "id": "Dir-Listing",
            "name": "Directory Listing Enabled",
            "description_template": "Directory listing enabled on {} exposing file structure",
            "severity_options": ["Medium"],
        },
        {
            "id": "Default-Files",
            "name": "Default or Backup Files Detected",
            "description_template": "Default or backup files (e.g., .bak, .old) found on {}",
            "severity_options": ["Low", "Medium"],
        },
        {
            "id": "Misconfig",
            "name": "Web Server Misconfiguration",
            "description_template": "Web server on {} exposes sensitive configuration details",
            "severity_options": ["Medium", "High"],
        },
    ]

    # Randomly select 1 to 3 issues
    num_issues = random.randint(1, 3)
    selected_issues = random.sample(possible_issues, num_issues)

    # Assign random severity levels and format descriptions
    vulnerabilities = [
        {
            "tool": "Nikto",
            "id": issue["id"],
            "name": issue["name"],
            "url": url,
            "severity": random.choice(issue["severity_options"]),
            "description": issue["description_template"].format(domain),
            "details": issue,
            "cvss_score": None,  # Optional: can be set if needed
            "remediation": "Review server configuration and update software.",
        }
        for issue in selected_issues
    ]

    # Optionally add CMS-specific issue
    if (
        "wordpress" in domain.lower() or "wp" in domain.lower()
    ) and random.random() < 0.5:
        vulnerabilities.append(
            {
                "tool": "Nikto",
                "id": "CMS-Config",
                "name": "WordPress Configuration Exposure",
                "url": url,
                "severity": "High",
                "description": "WordPress configuration files (e.g., wp-config.php) potentially accessible on {}".format(
                    domain
                ),
                "details": {},
                "cvss_score": None,
                "remediation": "Restrict access to sensitive CMS files.",
            }
        )

    return {
        "simulated": True,
        "url": url,
        "scan_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "vulnerabilities": vulnerabilities,
        "details": "This is a simulated Nikto scan as Nikto was not found in the system.",
    }


def simulate_zap_scan(url):
    """Simulate ZAP scan results when ZAP CLI is not available"""
    domain = urlparse(url).netloc

    # Define a pool of possible ZAP findings
    possible_findings = [
        {
            "name": "X-Frame-Options Header Not Set",
            "risk_options": ["Low", "Medium"],
            "description": "X-Frame-Options header is not included in the HTTP response to protect against 'ClickJacking' attacks.",
        },
        {
            "name": "X-Content-Type-Options Header Missing",
            "risk_options": ["Low"],
            "description": "The X-Content-Type-Options header is not set, potentially allowing MIME type mismatches.",
        },
        {
            "name": "Cross-Site Scripting (Reflected)",
            "risk_options": ["Low", "Medium"],
            "description": "Reflected Cross-site scripting (XSS) may be possible. Manual validation required.",
        },
        {
            "name": "Content Security Policy (CSP) Missing",
            "risk_options": ["Low", "Medium"],
            "description": "No Content Security Policy detected, increasing risk of XSS attacks.",
        },
        {
            "name": "Server Information Disclosure",
            "risk_options": ["Low"],
            "description": "Server headers may expose software versions, aiding attackers.",
        },
    ]

    # Randomly select 1 to 4 findings
    num_findings = random.randint(1, 4)
    selected_findings = random.sample(possible_findings, num_findings)

    # Assign random risk levels from available options
    findings = [
        {
            "name": finding["name"],
            "risk": random.choice(finding["risk_options"]),
            "description": finding["description"],
        }
        for finding in selected_findings
    ]

    return {
        "simulated": True,
        "url": url,
        "findings": findings,
        "details": "This is a simulated ZAP scan as zap-cli was not found in the system.",
    }


def simulate_nessus_scan(url):
    """Simulate Nessus scan results (since we can't directly integrate)"""
    domain = urlparse(url).netloc

    # Define a pool of possible Nessus vulnerabilities
    possible_vulns = [
        {
            "id": "SSL/TLS",
            "name": "SSL/TLS Configuration",
            "description_template": "Potential SSL/TLS vulnerabilities on {}",
            "cvss_range": (4.0, 6.0),
        },
        {
            "id": "Open Ports",
            "name": "Potentially Unnecessary Open Ports",
            "description_template": "{} has several ports that may be unnecessarily exposed",
            "cvss_range": (3.5, 4.5),
        },
        {
            "id": "Outdated Software",
            "name": "Outdated Software Detected",
            "description_template": "Outdated software versions detected on {}",
            "cvss_range": (4.0, 6.5),
        },
        {
            "id": "Weak Credentials",
            "name": "Weak Credential Configuration",
            "description_template": "Weak or default credentials detected on {}",
            "cvss_range": (5.0, 7.0),
        },
    ]

    # Always include at least one vulnerability, with a chance for more
    simulated_vulns = []
    if random.random() < 0.9:  # 90% chance to include SSL/TLS
        vuln = possible_vulns[0]
        simulated_vulns.append(
            {
                "id": vuln["id"],
                "name": vuln["name"],
                "description": vuln["description_template"].format(domain),
                "cvss_score": round(random.uniform(*vuln["cvss_range"]), 1),
            }
        )

    # Randomly add 0 to 2 additional vulnerabilities
    other_vulns = random.sample(possible_vulns[1:], random.randint(0, 2))
    for vuln in other_vulns:
        simulated_vulns.append(
            {
                "id": vuln["id"],
                "name": vuln["name"],
                "description": vuln["description_template"].format(domain),
                "cvss_score": round(random.uniform(*vuln["cvss_range"]), 1),
            }
        )

    # Conditionally add WordPress-specific vulnerability with 50% probability if relevant
    if (
        "wordpress" in domain.lower() or "wp" in domain.lower()
    ) and random.random() < 0.5:
        simulated_vulns.append(
            {
                "id": "WordPress",
                "name": "WordPress Version Exposure",
                "description": "WordPress version exposed in meta tags on {}".format(
                    domain
                ),
                "cvss_score": round(random.uniform(3.0, 4.0), 1),
            }
        )

    return {
        "url": url,
        "scan_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "vulnerabilities": simulated_vulns,
    }


def parse_sqlmap_results(results):
    """Parse SQLMap results (real or simulated) into normalized vulnerability format"""
    vulnerabilities = []

    # If simulated scan (our new format)
    if isinstance(results, dict) and results.get("simulated", False):
        # Already normalized
        vulnerabilities.extend(results.get("vulnerabilities", []))
        return vulnerabilities

    # If real scan output (legacy/CLI output)
    # Try to detect findings in various possible formats
    has_findings = False
    if isinstance(results, dict):
        if "findings" in results and results["findings"].get("vulnerable", False):
            has_findings = True
        elif (
            "stdout" in results
            and "injection" in results["stdout"].lower()
            and "found" in results["stdout"].lower()
        ):
            has_findings = True
        elif "log_contents" in results:
            for content in results["log_contents"].values():
                if "injection" in content.lower() and "found" in content.lower():
                    has_findings = True
                    break

    if has_findings:
        vuln = {
            "tool": "SQLMap",
            "type": "SQL Injection",
            "url": results.get("url", "Unknown URL"),
            "severity": "High",
            "description": "SQL Injection vulnerability found",
            "details": results,
            "cvss_score": 8.6,  # SQL injection typically scores high
            "remediation": "Use parameterized queries, input validation, and ORM frameworks.",
        }
        vulnerabilities.append(vuln)

    return vulnerabilities


import re


def parse_nikto_results(results):
    """Parse Nikto results (real or simulated) into normalized vulnerability format"""
    vulnerabilities = []

    # If simulated scan (our new format)
    if isinstance(results, dict) and results.get("simulated", False):
        vulnerabilities.extend(results.get("vulnerabilities", []))
        return vulnerabilities

    # If real scan output (legacy)
    if isinstance(results, dict) and "output" in results:
        output = results["output"]
        for line in output.split("\n"):
            if "+ " in line:
                # Try to extract vulnerability description
                match = re.search(r"\+ ([^:]+): (.*)", line)
                if match:
                    vuln_type = match.group(1)
                    description = match.group(2)
                    osvdb_match = re.search(r"OSVDB-(\d+)", line)
                    osvdb_id = osvdb_match.group(1) if osvdb_match else "N/A"
                    vulnerabilities.append(
                        {
                            "tool": "Nikto",
                            "type": vuln_type,
                            "id": osvdb_id,
                            "url": results.get("url", "Unknown URL"),
                            "severity": "Medium",  # Default, or parse if available
                            "description": description,
                            "details": line,
                            "cvss_score": None,
                            "remediation": "Review server configuration and update software.",
                        }
                    )
    return vulnerabilities


def parse_zap_results(results):
    """Parse OWASP ZAP results into normalized vulnerability format"""
    vulnerabilities = []

    # Handle simulated ZAP results
    if (
        isinstance(results, dict)
        and results.get("simulated", False)
        and "findings" in results
    ):
        for finding in results["findings"]:
            risk_mapping = {
                "High": 7.5,
                "Medium": 5.0,
                "Low": 2.5,
                "Informational": 0.0,
            }

            cvss_score = risk_mapping.get(finding.get("risk", "Low"), None)

            vuln = {
                "tool": "OWASP ZAP (Simulated)",
                "type": finding.get("name", "Unknown"),
                "url": results.get("url", "Unknown URL"),
                "description": finding.get("description", "No description"),
                "details": {"risk": finding.get("risk", "Unknown")},
                "cvss_score": cvss_score,
                "remediation": "Review ZAP findings and implement appropriate security controls.",
            }
            vulnerabilities.append(vuln)
        return vulnerabilities

    # Handle actual ZAP results
    if isinstance(results, dict) and "output" in results:
        try:
            # Parse XML output
            root = ET.fromstring(results["output"])

            for site in root.findall(".//site"):
                site_url = site.get("name", "")

                for alert in site.findall(".//alertitem"):
                    name = (
                        alert.find("name").text
                        if alert.find("name") is not None
                        else "Unknown"
                    )
                    risk = (
                        alert.find("riskdesc").text
                        if alert.find("riskdesc") is not None
                        else "Unknown"
                    )
                    desc = (
                        alert.find("desc").text
                        if alert.find("desc") is not None
                        else "No description"
                    )
                    solution = (
                        alert.find("solution").text
                        if alert.find("solution") is not None
                        else "No solution provided"
                    )

                    # Map ZAP risk to approximate CVSS score
                    cvss_mapping = {
                        "High": 7.5,
                        "Medium": 5.0,
                        "Low": 2.5,
                        "Informational": 0.0,
                    }

                    risk_level = risk.split(" ")[0] if " " in risk else risk
                    cvss_score = cvss_mapping.get(risk_level, None)

                    vuln = {
                        "tool": "OWASP ZAP",
                        "type": name,
                        "url": site_url,
                        "description": desc,
                        "details": {"risk": risk},
                        "cvss_score": cvss_score,
                        "remediation": solution,
                    }
                    vulnerabilities.append(vuln)

        except ET.ParseError:
            # If XML parsing fails, try to extract data from plain text
            output = results["output"]
            lines = output.split("\n")

            for i, line in enumerate(lines):
                if "alert" in line.lower() and i + 1 < len(lines):
                    vuln = {
                        "tool": "OWASP ZAP",
                        "type": "Potential Vulnerability",
                        "description": line + "\n" + lines[i + 1],
                        "details": {},
                        "cvss_score": None,  # To be predicted
                        "remediation": "Review ZAP output for details.",
                    }
                    vulnerabilities.append(vuln)

    return vulnerabilities


def parse_nessus_results(results):
    """Parse Nessus results into normalized vulnerability format"""
    vulnerabilities = []

    if isinstance(results, dict) and "vulnerabilities" in results:
        for vuln_data in results["vulnerabilities"]:
            vuln = {
                "tool": "Nessus",
                "type": vuln_data.get("name", "Unknown"),
                "id": vuln_data.get("id", "N/A"),
                "description": vuln_data.get("description", "No description"),
                "details": vuln_data,
                "cvss_score": vuln_data.get("cvss_score"),
                "remediation": "Update affected software and review configuration.",
            }
            vulnerabilities.append(vuln)

    return vulnerabilities


def predict_cvss_score(vulnerability):
    """Predict CVSS score using machine learning models"""
    try:
        # Check if models directory exists
        if not os.path.exists("models"):
            os.makedirs("models", exist_ok=True)

        # Check if models exist
        models_exist = all(os.path.exists(path) for path in MODEL_PATHS.values())

        if not models_exist:
            print("ML models not found, using default scoring")
            return default_cvss_scoring(vulnerability)

        # Extract features for prediction
        features = extract_features(vulnerability)

        # Load models and make predictions
        predictions = []

        # Random Forest prediction
        rf_model = joblib.load(MODEL_PATHS["rf"])
        rf_pred = rf_model.predict([features])[0]
        predictions.append(rf_pred)

        # SVM prediction
        svm_model = joblib.load(MODEL_PATHS["svm"])
        svm_pred = svm_model.predict([features])[0]
        predictions.append(svm_pred)

        # Neural Network prediction
        nn_model = joblib.load(MODEL_PATHS["nn"])
        nn_pred = nn_model.predict([features])[0]
        predictions.append(nn_pred)

        # Average predictions (ensemble approach)
        avg_score = sum(predictions) / len(predictions)

        # Ensure score is in range 0-10
        return max(0, min(10, avg_score))

    except Exception as e:
        print(f"Error predicting CVSS score: {e}")
        return default_cvss_scoring(vulnerability)


def extract_features(vulnerability):
    """Extract features from vulnerability for ML prediction"""
    # This is a simplified feature extraction - in a real system this would be more complex
    features = np.zeros(20)  # Using a fixed size feature vector

    # Feature 1-4: Tool type (one-hot encoding)
    tool = vulnerability.get("tool", "").lower()
    if "sqlmap" in tool:
        features[0] = 1
    elif "nikto" in tool:
        features[1] = 1
    elif "zap" in tool:
        features[2] = 1
    elif "nessus" in tool:
        features[3] = 1

    # Feature 5-10: Vulnerability type keywords
    vuln_type = vulnerability.get("type", "").lower()
    description = vulnerability.get("description", "").lower()

    if "sql" in vuln_type or "sql" in description:
        features[4] = 1
    if "xss" in vuln_type or "cross site" in description:
        features[5] = 1
    if "ssl" in vuln_type or "tls" in description:
        features[6] = 1
    if "dos" in vuln_type or "denial of service" in description:
        features[7] = 1
    if "rce" in vuln_type or "remote code" in description or "command" in description:
        features[8] = 1
    if "csrf" in vuln_type or "cross site request" in description:
        features[9] = 1

    # Feature 11-15: Description length and keyword counts
    features[10] = min(len(description) / 100, 5)  # Normalized description length
    features[11] = description.count("critical")
    features[12] = description.count("high")
    features[13] = description.count("medium") + description.count("moderate")
    features[14] = description.count("low")

    # Feature 16-20: Additional contextual features
    features[15] = 1 if "authentication" in description else 0
    features[16] = 1 if "password" in description else 0
    features[17] = (
        1
        if "data" in description
        and ("leak" in description or "exposure" in description)
        else 0
    )
    features[18] = 1 if "patch" in description else 0
    features[19] = 1 if "cve" in description else 0

    return features


def default_cvss_scoring(vulnerability):
    """Default CVSS scoring when ML prediction is not available"""
    # Simple keyword-based scoring
    vuln_type = vulnerability.get("type", "").lower()
    description = vulnerability.get("description", "").lower()

    if any(
        kw in vuln_type or kw in description
        for kw in ["sql injection", "rce", "remote code"]
    ):
        return 8.5
    elif any(kw in vuln_type or kw in description for kw in ["xss", "cross site"]):
        return 6.5
    elif any(
        kw in vuln_type or kw in description for kw in ["csrf", "cross site request"]
    ):
        return 5.5
    elif any(
        kw in vuln_type or kw in description for kw in ["ssl", "tls", "configuration"]
    ):
        return 4.5
    elif any(
        kw in vuln_type or kw in description
        for kw in ["information disclosure", "exposure"]
    ):
        return 3.5
    else:
        return 2.0


def get_severity_from_cvss(cvss_score):
    """Map CVSS score to severity level"""
    if cvss_score is None:
        return "None"

    for severity, (min_score, max_score) in CVSS_SEVERITY.items():
        if min_score <= cvss_score <= max_score:
            return severity

    return "None"
