import os
import json
import threading
import time
import numpy as np
import random
from datetime import datetime
from urllib.parse import urlparse
import xml.etree.ElementTree as ET
import joblib

# SQLAlchemy imports
from sqlalchemy import create_engine, Column, String, DateTime, JSON
from sqlalchemy.orm import declarative_base, sessionmaker

# -----------------------------
# DATABASE SETUP
# -----------------------------
# Use PostgreSQL on Render if DATABASE_URL is set, else fallback to SQLite locally
DATABASE_URL = os.environ.get("DATABASE_URL", "sqlite:///db/scans.db")

engine = create_engine(DATABASE_URL, echo=False, future=True)
SessionLocal = sessionmaker(bind=engine)
session = SessionLocal()
Base = declarative_base()


class Scan(Base):
    __tablename__ = "scans"
    scan_id = Column(String, primary_key=True, index=True)
    url = Column(String, nullable=False)
    scan_date = Column(DateTime, nullable=False)
    status = Column(String, default="in_progress")
    tool_results = Column(JSON, nullable=True)
    vulnerabilities = Column(JSON, nullable=True)
    report_path = Column(String, nullable=True)


# Create tables
Base.metadata.create_all(bind=engine)

# -----------------------------
# CVSS Scoring
# -----------------------------
CVSS_SEVERITY = {
    "Critical": (9.0, 10.0),
    "High": (7.0, 8.9),
    "Medium": (4.0, 6.9),
    "Low": (0.1, 3.9),
    "None": (0.0, 0.0),
}

# ML model paths
MODEL_PATHS = {
    "rf": "models/rf_model.pkl",
    "svm": "models/svm_model.pkl",
    "nn": "models/nn_model.pkl",
}

# -----------------------------
# DATABASE FUNCTIONS
# -----------------------------
def init_db():
    """SQLAlchemy handles DB initialization automatically."""
    pass


def add_scan(scan_id, url, scan_date):
    scan = Scan(scan_id=scan_id, url=url, scan_date=scan_date, status="in_progress")
    session.add(scan)
    session.commit()


def update_scan_status(scan_id, status, tool_results=None, vulnerabilities=None):
    scan = session.query(Scan).filter(Scan.scan_id == scan_id).first()
    if scan:
        scan.status = status
        if tool_results:
            scan.tool_results = tool_results
        if vulnerabilities:
            scan.vulnerabilities = vulnerabilities
        session.commit()


def save_scan_results(scan_id, results, report_path=None):
    scan = session.query(Scan).filter(Scan.scan_id == scan_id).first()
    if scan:
        scan.tool_results = results
        scan.vulnerabilities = results.get("vulnerabilities", [])
        if report_path:
            scan.report_path = report_path
        scan.status = "completed"
        session.commit()


def get_scan_results(scan_id):
    scan = session.query(Scan).filter(Scan.scan_id == scan_id).first()
    if scan:
        return {
            "scan_id": scan.scan_id,
            "url": scan.url,
            "scan_date": str(scan.scan_date),
            "status": scan.status,
            "tool_results": scan.tool_results,
            "vulnerabilities": scan.vulnerabilities,
            "report_path": scan.report_path,
        }
    return None


def get_all_scans():
    scans = session.query(Scan).order_by(Scan.scan_date.desc()).all()
    return scans


# -----------------------------
# SCANNING LOGIC
# -----------------------------
def scan_url(scan_id, url, scan_date):
    """Create DB entry and run scans in background."""
    add_scan(scan_id, url, scan_date)
    thread = threading.Thread(target=run_scans, args=(scan_id, url))
    thread.daemon = True
    thread.start()


def run_scans(scan_id, url):
    """Run simulated or real scans, compute CVSS, update DB."""
    try:
        results = {}
        vulnerabilities = []

        # Simulated scans
        results["sqlmap"] = simulate_sqlmap_scan(url)
        vulnerabilities.extend(parse_sqlmap_results(results["sqlmap"]))

        results["nikto"] = simulate_nikto_scan(url)
        vulnerabilities.extend(parse_nikto_results(results["nikto"]))

        results["zap"] = simulate_zap_scan(url)
        vulnerabilities.extend(parse_zap_results(results["zap"]))

        results["nessus"] = simulate_nessus_scan(url)
        vulnerabilities.extend(parse_nessus_results(results["nessus"]))

        # Predict CVSS for missing scores
        for vuln in vulnerabilities:
            if "cvss_score" not in vuln or not vuln["cvss_score"]:
                vuln["cvss_score"] = predict_cvss_score(vuln)
            vuln["severity"] = get_severity_from_cvss(vuln["cvss_score"])

        # Group vulnerabilities by severity
        vuln_by_severity = {sev: [] for sev in CVSS_SEVERITY}
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "None")
            vuln_by_severity[severity].append(vuln)

        # Save results
        save_scan_results(scan_id, {"vulnerabilities": vulnerabilities, "tools": results})
        print(f"[INFO] Scan completed for {url}")

    except Exception as e:
        print(f"[ERROR] Scan failed for {url}: {e}")
        update_scan_status(scan_id, "failed")


# -----------------------------
# SIMULATION FUNCTIONS
# -----------------------------
def simulate_sqlmap_scan(url):
    domain = urlparse(url).netloc
    possible_findings = [
        {"type": "SQL Injection", "parameter": "id", "risk_options": ["Medium", "High"], "description": 'Potential SQL Injection in "id"'},
        {"type": "Boolean-based Blind SQL Injection", "parameter": "search", "risk_options": ["Medium"], "description": 'Boolean-based blind SQL injection in "search"'},
        {"type": "Time-based Blind SQL Injection", "parameter": "category", "risk_options": ["Medium", "High"], "description": 'Time-based blind SQL injection in "category"'},
    ]
    selected = random.sample(possible_findings, random.randint(0, 2)) if possible_findings else []
    vulnerabilities = [
        {"tool": "SQLMap", "type": f["type"], "parameter": f["parameter"], "url": url,
         "severity": random.choice(f["risk_options"]), "description": f["description"],
         "cvss_score": 8.6, "remediation": "Use parameterized queries"} for f in selected
    ]
    return {"simulated": True, "url": url, "vulnerabilities": vulnerabilities}


def simulate_nikto_scan(url):
    domain = urlparse(url).netloc
    possible_issues = [
        {"id": "HTTP-Methods", "name": "Unusual HTTP Methods Enabled", "severity_options": ["Low", "Medium"]},
        {"id": "Dir-Listing", "name": "Directory Listing Enabled", "severity_options": ["Medium"]},
    ]
    selected = random.sample(possible_issues, random.randint(1, len(possible_issues)))
    vulnerabilities = [
        {"tool": "Nikto", "id": i["id"], "name": i["name"], "url": url,
         "severity": random.choice(i["severity_options"]), "cvss_score": 5.0, "remediation": "Review server config"} for i in selected
    ]
    return {"simulated": True, "url": url, "vulnerabilities": vulnerabilities}


def simulate_zap_scan(url):
    return {"simulated": True, "url": url, "findings": [{"name": "XSS", "risk": "Medium", "description": "Simulated XSS"}]}


def simulate_nessus_scan(url):
    return {"simulated": True, "url": url, "vulnerabilities": [{"name": "SSL/TLS", "cvss]()
